
<html>
<title>sprite - Pygame Documentation</title>
<body bgcolor=#aaeebb text=#000000 link=#331111 vlink=#331111>


<table cellpadding=0 cellspacing=0 border=0 style='border: 3px solid black;' width='100%'>
<tr>
<td bgcolor='#c2fc20' style='padding: 6px;' align=center valign=center><a href='http://www.pygame.org/'><img src='../pygame_tiny.gif' border=0 width=200 height=60></a><br><b>pygame documentation</b></td>
<td bgcolor='#6aee28' style='border-left: 3px solid black; padding: 6px;' align=center valign=center>
	||&nbsp;
	<a href=http://www.pygame.org>Pygame Home</a> &nbsp;||&nbsp;
	<a href=../index.html>Help Contents</a> &nbsp;||
	<a href=index.html>Reference Index</a> &nbsp;||
	<br>&nbsp;<br>
	
<a href=cdrom.html>Cdrom</a>&nbsp;||&nbsp;
<a href=cursors.html>Cursors</a>&nbsp;||&nbsp;
<a href=display.html>Display</a>&nbsp;||&nbsp;
<a href=draw.html>Draw</a>&nbsp;||&nbsp;
<a href=event.html>Event</a>&nbsp;||&nbsp;
<a href=font.html>Font</a>&nbsp;||&nbsp;
<a href=image.html>Image</a>&nbsp;||&nbsp;
<a href=joystick.html>Joystick</a>&nbsp;||&nbsp;
<a href=key.html>Key</a>&nbsp;||&nbsp;
<a href=mixer.html>Mixer</a>&nbsp;||&nbsp;
<a href=mouse.html>Mouse</a>&nbsp;||&nbsp;
<a href=movie.html>Movie</a>&nbsp;||&nbsp;
<a href=music.html>Music</a>&nbsp;||&nbsp;
<a href=overlay.html>Overlay</a>&nbsp;||&nbsp;
<a href=pygame.html>Pygame</a>&nbsp;||&nbsp;
<a href=rect.html>Rect</a>&nbsp;||&nbsp;
<a href=scrap.html>Scrap</a>&nbsp;||&nbsp;
<a href=sndarray.html>Sndarray</a>&nbsp;||&nbsp;
<a href=sprite.html>Sprite</a>&nbsp;||&nbsp;
<a href=surface.html>Surface</a>&nbsp;||&nbsp;
<a href=surfarray.html>Surfarray</a>&nbsp;||&nbsp;
<a href=time.html>Time</a>&nbsp;||&nbsp;
<a href=transform.html>Transform</a>
</td></tr></table>
<br>


<a name="pygame.sprite">
<big><b>pygame.sprite</big></b><br><ul>
  <i>pygame module with basic game object classes</i><br>
<ul><small><table>
  <tr><td><a href="sprite.html#pygame.sprite.Sprite">pygame.sprite.Sprite</a> - <font size=-1>simple base class for visible game objects</font></td><td>simple base class for visible game objects</td></tr>
  <tr><td><a href="sprite.html#pygame.sprite.Group">pygame.sprite.Group</a> - <font size=-1>container class for many Sprites</font></td><td>container class for many Sprites</td></tr>
  <tr><td><a href="sprite.html#pygame.sprite.RenderUpdates">pygame.sprite.RenderUpdates</a> - <font size=-1>Group class that tracks dirty updates</font></td><td>Group class that tracks dirty updates</td></tr>
  <tr><td><a href="sprite.html#pygame.sprite.OrderedUpdates">pygame.sprite.OrderedUpdates</a> - <font size=-1>RenderUpdates class that draws Sprites in order of addition</font></td><td>RenderUpdates class that draws Sprites in order of addition</td></tr>
  <tr><td><a href="sprite.html#pygame.sprite.GroupSingle">pygame.sprite.GroupSingle</a> - <font size=-1>Group container that holds a single Sprite</font></td><td>Group container that holds a single Sprite</td></tr>
  <tr><td><a href="sprite.html#pygame.sprite.spritecollide">pygame.sprite.spritecollide</a> - <font size=-1>find Sprites in a Group that intersect another Sprite</font></td><td>find Sprites in a Group that intersect another Sprite</td></tr>
  <tr><td><a href="sprite.html#pygame.sprite.groupcollide">pygame.sprite.groupcollide</a> - <font size=-1>find all Sprites that collide between two Groups</font></td><td>find all Sprites that collide between two Groups</td></tr>
  <tr><td><a href="sprite.html#pygame.sprite.spritecollideany">pygame.sprite.spritecollideany</a> - <font size=-1>simple test if a Sprite intersects anything in a Group</font></td><td>simple test if a Sprite intersects anything in a Group</td></tr>
</table></small></ul>
<p>This module contains several simple classes to be used within games. There is the main Sprite class and several Group classes that contain Sprites. The use of these classes is entirely optional when using Pygame. The classes are fairly lightweight and only provide a starting place for the code that is common to most games. </p>
<p>The Sprite class is intended to be used as a base class for the different types of objects in the game. There is also a base Group class that simply stores sprites. <tt>A</tt> game could create new types of Group classes that operate on specially customized Sprite instances they contain. </p>
<p>The basic Sprite class can draw the Sprites it contains to a Surface. The <tt><a href="sprite.html#Group.draw">Group.draw</a> - <font size=-1>blit the Sprite images</font></tt> method requires that each Sprite have a <tt>Surface.image</tt> attribute and a <tt>Surface.rect</tt>. The <tt><a href="sprite.html#Group.clear">Group.clear</a> - <font size=-1>draw a background over the Sprites</font></tt> method requires these same attributes, and can be used to erase all the Sprites with background. There are also more advanced Groups: <tt><a href="sprite.html#pygame.sprite.RenderUpdates">pygame.sprite.RenderUpdates</a> - <font size=-1>Group class that tracks dirty updates</font></tt> and <tt><a href="sprite.html#pygame.sprite.OrderedUpdates">pygame.sprite.OrderedUpdates</a> - <font size=-1>RenderUpdates class that draws Sprites in order of addition</font></tt>. </p>
<p>Lastly, this module contains several collision functions. These help find sprites inside multiple groups that have intersecting bounding rectangles. To find the collisions, the Sprites are required to have a <tt>Surface.rect</tt> attribute assigned. </p>
<p>The groups are designed for high efficiency in removing and adding Sprites to them. They also allow cheap testing to see if a Sprite already exists in a Group. <tt>A</tt> given Sprite can exist in any number of groups. <tt>A</tt> game could use some groups to control object rendering, and a completely separate set of groups to control interaction or player movement. Instead of adding type attributes or booleans to a derived Sprite class, consider keeping the Sprites inside organized Groups. This will allow for easier lookup later in the game. </p>
<p>Sprites and Groups manage their relationships with the add() and remove() methods. These methods can accept a single or multiple targets for membership. The default initializers for these classes also takes a single or list of targets for initial membership. It is safe to repeatedly add and remove the same Sprite from a Group. </p>
<p>While it is possible to design sprite and group classes that don't derive from the Sprite and AbstractGroup classes below, it is strongly recommended that you extend those when you add a Sprite or Group class. </p>
<p>Sprites are not thread safe. So lock them yourself if using threads. </p>
<!--COMMENTS:pygame.sprite--> &nbsp;<br> 


<a name="pygame.sprite.Sprite">
<big><b>pygame.sprite.Sprite</big></b><br><ul>
  <i>simple base class for visible game objects</i><br>
  <tt>pygame.sprite.Sprite(*groups): return Sprite</tt><br>
<ul><small><table>
  <tr><td><a href="sprite.html#Sprite.update">Sprite.update</a> - <font size=-1>method to control sprite behavior</font></td><td>method to control sprite behavior</td></tr>
  <tr><td><a href="sprite.html#Sprite.add">Sprite.add</a> - <font size=-1>add the sprite to groups</font></td><td>add the sprite to groups</td></tr>
  <tr><td><a href="sprite.html#Sprite.remove">Sprite.remove</a> - <font size=-1>remove the sprite from groups</font></td><td>remove the sprite from groups</td></tr>
  <tr><td><a href="sprite.html#Sprite.kill">Sprite.kill</a> - <font size=-1>remove the Sprite from all Groups</font></td><td>remove the Sprite from all Groups</td></tr>
  <tr><td><a href="sprite.html#Sprite.alive">Sprite.alive</a> - <font size=-1>does the sprite belong to any groups</font></td><td>does the sprite belong to any groups</td></tr>
  <tr><td><a href="sprite.html#Sprite.groups">Sprite.groups</a> - <font size=-1>list of Groups that contain this Sprite</font></td><td>list of Groups that contain this Sprite</td></tr>
</table></small></ul>
<p>The base class for visible game objects. Derived classes will want to override the <tt><a href="sprite.html#Sprite.update">Sprite.update</a> - <font size=-1>method to control sprite behavior</font></tt> and assign a <tt>Sprite.image</tt> and <tt>Sprite.rect</tt> attributes. The initializer can accept any number of Group instances to be added to. </p>
<p>When subclassing the Sprite, be sure to call the base initializer before adding the Sprite to Groups. </p>
<!--COMMENTS:pygame.sprite.Sprite--> &nbsp;<br> 


<a name="Sprite.update">
<big><b>Sprite.update</big></b><br><ul>
  <i>method to control sprite behavior</i><br>
  <tt>Sprite.update(*args):</tt><br>
<p>The default implementation of this method does nothing; it's just a convenient "hook" that you can override. This method is called by <tt><a href="sprite.html#Group.update">Group.update</a> - <font size=-1>call the update method on contained Sprites</font></tt> with whatever arguments you give it. </p>
<p>There is no need to use this method if not using the convenience method by the same name in the Group class. </p>
<!--COMMENTS:Sprite.update--> &nbsp;<br> 
<br></ul>


<a name="Sprite.add">
<big><b>Sprite.add</big></b><br><ul>
  <i>add the sprite to groups</i><br>
  <tt>Sprite.add(*groups): return None</tt><br>
<p>Any number of Group instances can be passed as arguments. The Sprite will be added to the Groups it is not already a member of. </p>
<!--COMMENTS:Sprite.add--> &nbsp;<br> 
<br></ul>


<a name="Sprite.remove">
<big><b>Sprite.remove</big></b><br><ul>
  <i>remove the sprite from groups</i><br>
  <tt>Sprite.remove(*groups): return None</tt><br>
<p>Any number of Group instances can be passed as arguments. The Sprite will be removed from the Groups it is currently a member of. </p>
<!--COMMENTS:Sprite.remove--> &nbsp;<br> 
<br></ul>


<a name="Sprite.kill">
<big><b>Sprite.kill</big></b><br><ul>
  <i>remove the Sprite from all Groups</i><br>
  <tt>Sprite.kill(): return None</tt><br>
<p>The Sprite is removed from all the Groups that contain it. This won't change anything about the state of the Sprite. It is possible to continue to use the Sprite after this method has been called, including adding it to Groups. </p>
<!--COMMENTS:Sprite.kill--> &nbsp;<br> 
<br></ul>


<a name="Sprite.alive">
<big><b>Sprite.alive</big></b><br><ul>
  <i>does the sprite belong to any groups</i><br>
  <tt>Sprite.alive(): return bool</tt><br>
<p>Returns True when the Sprite belongs to one or more Groups. </p>
<!--COMMENTS:Sprite.alive--> &nbsp;<br> 
<br></ul>


<a name="Sprite.groups">
<big><b>Sprite.groups</big></b><br><ul>
  <i>list of Groups that contain this Sprite</i><br>
  <tt>Sprite.groups(): return group_list</tt><br>
<p>Return a list of all the Groups that contain this Sprite. </p>
<!--COMMENTS:Sprite.groups--> &nbsp;<br> 
<br></ul>
<br></ul>


<a name="pygame.sprite.Group">
<big><b>pygame.sprite.Group</big></b><br><ul>
  <i>container class for many Sprites</i><br>
  <tt>pygame.sprite.Group(*sprites): return Group</tt><br>
<ul><small><table>
  <tr><td><a href="sprite.html#Group.sprites">Group.sprites</a> - <font size=-1>list of the Sprites this Group contains</font></td><td>list of the Sprites this Group contains</td></tr>
  <tr><td><a href="sprite.html#Group.copy">Group.copy</a> - <font size=-1>duplicate the Group</font></td><td>duplicate the Group</td></tr>
  <tr><td><a href="sprite.html#Group.add">Group.add</a> - <font size=-1>add Sprites to this Group</font></td><td>add Sprites to this Group</td></tr>
  <tr><td><a href="sprite.html#Group.remove">Group.remove</a> - <font size=-1>remove Sprites from the Group</font></td><td>remove Sprites from the Group</td></tr>
  <tr><td><a href="sprite.html#Group.has">Group.has</a> - <font size=-1>test if a Group contains Sprites</font></td><td>test if a Group contains Sprites</td></tr>
  <tr><td><a href="sprite.html#Group.update">Group.update</a> - <font size=-1>call the update method on contained Sprites</font></td><td>call the update method on contained Sprites</td></tr>
  <tr><td><a href="sprite.html#Group.draw">Group.draw</a> - <font size=-1>blit the Sprite images</font></td><td>blit the Sprite images</td></tr>
  <tr><td><a href="sprite.html#Group.clear">Group.clear</a> - <font size=-1>draw a background over the Sprites</font></td><td>draw a background over the Sprites</td></tr>
  <tr><td><a href="sprite.html#Group.empty">Group.empty</a> - <font size=-1>remove all Sprites</font></td><td>remove all Sprites</td></tr>
</table></small></ul>
<p><tt>A</tt> simple container for Sprite objects. This class can be inherited to create containers with more specific behaviors. The constructor takes any number of Sprite arguments to add to the Group. The group supports the following standard Python operations: </p>
<pre>    in      test if a Sprite is contained
    len     the number of Sprites contained
    bool    test if any Sprites are contained
    iter    iterate through all the Sprites
</pre><p>The Sprites in the Group are not ordered, so drawing and iterating the Sprites is in no particular order. </p>
<!--COMMENTS:pygame.sprite.Group--> &nbsp;<br> 


<a name="Group.sprites">
<big><b>Group.sprites</big></b><br><ul>
  <i>list of the Sprites this Group contains</i><br>
  <tt>Group.sprites(): return sprite_list</tt><br>
<p>Return a list of all the Sprites this group contains. You can also get an iterator from the group, but you cannot iterator over a Group while modifying it. </p>
<!--COMMENTS:Group.sprites--> &nbsp;<br> 
<br></ul>


<a name="Group.copy">
<big><b>Group.copy</big></b><br><ul>
  <i>duplicate the Group</i><br>
  <tt>Group.copy(): return Group</tt><br>
<p>Creates a new Group with all the same Sprites as the original. If you have subclassed Group, the new object will have the same (sub-)class as the original. This only works if the derived class's constructor takes the same arguments as the Group class's. </p>
<!--COMMENTS:Group.copy--> &nbsp;<br> 
<br></ul>


<a name="Group.add">
<big><b>Group.add</big></b><br><ul>
  <i>add Sprites to this Group</i><br>
  <tt>Group.add(*sprites): return None</tt><br>
<p>Add any number of Sprites to this Group. This will only add Sprites that are not already members of the Group. </p>
<p>Each sprite argument can also be a iterator containing Sprites. </p>
<!--COMMENTS:Group.add--> &nbsp;<br> 
<br></ul>


<a name="Group.remove">
<big><b>Group.remove</big></b><br><ul>
  <i>remove Sprites from the Group</i><br>
  <tt>Group.remove(*sprites): return None</tt><br>
<p>Remove any number of Sprites from the Group. This will only remove Sprites that are already members of the Group. </p>
<p>Each sprite argument can also be a iterator containing Sprites. </p>
<!--COMMENTS:Group.remove--> &nbsp;<br> 
<br></ul>


<a name="Group.has">
<big><b>Group.has</big></b><br><ul>
  <i>test if a Group contains Sprites</i><br>
  <tt>Group.has(*sprites): return None</tt><br>
<p>Return True if the Group contains all of the given sprites. This is similar to using the "in" operator on the Group ("if sprite in group: <tt>...")</tt>, which tests if a single Sprite belongs to a Group. </p>
<p>Each sprite argument can also be a iterator containing Sprites. </p>
<!--COMMENTS:Group.has--> &nbsp;<br> 
<br></ul>


<a name="Group.update">
<big><b>Group.update</big></b><br><ul>
  <i>call the update method on contained Sprites</i><br>
  <tt>Group.update(*args): return None</tt><br>
<p>Calls the update() method on all Sprites in the Group. The base Sprite class has an update method that takes any number of arguments and does nothing. The arguments passed to <tt><a href="sprite.html#Group.update">Group.update</a> - <font size=-1>call the update method on contained Sprites</font></tt> will be passed to each Sprite. </p>
<p>There is no way to get the return value from the <tt><a href="sprite.html#Sprite.update">Sprite.update</a> - <font size=-1>method to control sprite behavior</font></tt> methods. </p>
<!--COMMENTS:Group.update--> &nbsp;<br> 
<br></ul>


<a name="Group.draw">
<big><b>Group.draw</big></b><br><ul>
  <i>blit the Sprite images</i><br>
  <tt>Group.draw(Surface): return None</tt><br>
<p>Draws the contained Sprites to the Surface argument. This uses the <tt>Sprite.image</tt> attribute for the source surface, and <tt>Sprite.rect</tt> for the position. </p>
<p>The Group does not keep sprites in any order, so the draw order is arbitrary. </p>
<!--COMMENTS:Group.draw--> &nbsp;<br> 
<br></ul>


<a name="Group.clear">
<big><b>Group.clear</big></b><br><ul>
  <i>draw a background over the Sprites</i><br>
  <tt>Group.clear(Surface_dest, background): return None</tt><br>
<p>Erases the Sprites used in the last <tt><a href="sprite.html#Group.draw">Group.draw</a> - <font size=-1>blit the Sprite images</font></tt> call. The destination Surface is cleared by filling the drawn Sprite positions with the background. </p>
<p>The background is usually a Surface image the same dimensions as the destination Surface. However, it can also be a callback function that takes two arguments; the destination Surface and an area to clear. The background callback function will be called several times each clear. </p>
<p>Here is an example callback that will clear the Sprites with solid red: </p>
<pre>    def clear_callback(surf, rect):
        color = 255, 0, 0
        surf.fill(color, rect)
</pre>
<!--COMMENTS:Group.clear--> &nbsp;<br> 
<br></ul>


<a name="Group.empty">
<big><b>Group.empty</big></b><br><ul>
  <i>remove all Sprites</i><br>
  <tt>Group.empty(): return None</tt><br>
<p>Removes all Sprites from this Group. </p>
<!--COMMENTS:Group.empty--> &nbsp;<br> 
<br></ul>
<br></ul>


<a name="pygame.sprite.RenderUpdates">
<big><b>pygame.sprite.RenderUpdates</big></b><br><ul>
  <i>Group class that tracks dirty updates</i><br>
  <tt>pygame.sprite.RenderUpdates(*sprites): return RenderUpdates</tt><br>
<ul><small><table>
  <tr><td><a href="sprite.html#RenderUpdates.draw">RenderUpdates.draw</a> - <font size=-1>blit the Sprite images and track changed areas</font></td><td>blit the Sprite images and track changed areas</td></tr>
</table></small></ul>
<p>This class is derived from <tt><a href="sprite.html#pygame.sprite.Group">pygame.sprite.Group</a> - <font size=-1>container class for many Sprites</font></tt>. It has an extended draw() method that tracks the changed areas of the screen. </p>
<!--COMMENTS:pygame.sprite.RenderUpdates--> &nbsp;<br> 


<a name="RenderUpdates.draw">
<big><b>RenderUpdates.draw</big></b><br><ul>
  <i>blit the Sprite images and track changed areas</i><br>
  <tt>RenderUpdates.draw(surface): return Rect_list</tt><br>
<p>Draws all the Sprites to the surface, the same as <tt><a href="sprite.html#Group.draw">Group.draw</a> - <font size=-1>blit the Sprite images</font></tt>. This method also returns a list of Rectangular areas on the screen that have been changed. The returned changes include areas of the screen that have been affected by previous <tt><a href="sprite.html#Group.clear">Group.clear</a> - <font size=-1>draw a background over the Sprites</font></tt> calls. </p>
<p>The returned Rect list should be passed to <tt><a href="display.html#pygame.display.update">pygame.display.update</a> - <font size=-1>update portions of the screen for software displays</font></tt>. This will help performance on software driven display modes. This type of updating is usually only helpful on destinations with non-animating backgrounds. </p>
<!--COMMENTS:RenderUpdates.draw--> &nbsp;<br> 
<br></ul>
<br></ul>


<a name="pygame.sprite.OrderedUpdates">
<big><b>pygame.sprite.OrderedUpdates</big></b><br><ul>
  <i>RenderUpdates class that draws Sprites in order of addition</i><br>
  <tt>pygame.sprite.OrderedUpdates(*spites): return OrderedUpdates</tt><br>
<p>This class derives from <tt><a href="sprite.html#pygame.sprite.RenderUpdates">pygame.sprite.RenderUpdates</a> - <font size=-1>Group class that tracks dirty updates</font></tt>. It maintains the order in which the Sprites were added to the Group for rendering. This makes adding and removing Sprites from the Group a little slower than regular Groups. </p>
<!--COMMENTS:pygame.sprite.OrderedUpdates--> &nbsp;<br> 
<br></ul>


<a name="pygame.sprite.GroupSingle">
<big><b>pygame.sprite.GroupSingle</big></b><br><ul>
  <i>Group container that holds a single Sprite</i><br>
  <tt>pygame.sprite.GroupSingle(sprite=None): return GroupSingle</tt><br>
<p>The GroupSingle container only holds a single Sprite. When a new Sprite is added, the old one is removed. </p>
<p>There is a special property, <tt>GroupSingle.sprite</tt>, that accesses the Sprite that this Group contains. It can be None when the Group is empty. The property can also be assigned to add a Sprite into the GroupSingle container. </p>
<!--COMMENTS:pygame.sprite.GroupSingle--> &nbsp;<br> 
<br></ul>


<a name="pygame.sprite.spritecollide">
<big><b>pygame.sprite.spritecollide</big></b><br><ul>
  <i>find Sprites in a Group that intersect another Sprite</i><br>
  <tt>pygame.sprite.spritecollide(sprite, group, dokill): return Sprite_list</tt><br>
<p>Return a list containing all Sprites in a Group that intersect with another Sprite. Intersection is determined by comparing the <tt>Sprite.rect</tt> attribute of each Sprite. </p>
<p>The dokill argument is a boolean. If set to True, all Sprites that collide will be removed from the Group. </p>
<!--COMMENTS:pygame.sprite.spritecollide--> &nbsp;<br> 
<br></ul>


<a name="pygame.sprite.groupcollide">
<big><b>pygame.sprite.groupcollide</big></b><br><ul>
  <i>find all Sprites that collide between two Groups</i><br>
  <tt>pygame.sprite.groupcollide(group1, group2, dokill1, dokill2): return Sprite_dict</tt><br>
<p>This will find intersections between all the Sprites in two groups. Intersection is determined by comparing the <tt>Sprite.rect</tt> attribute of each Sprite. </p>
<p>Every Sprite inside group1 is added to the return dictionary. The value for each item is the list of Sprites in group2 that intersect. </p>
<p>If either dokill argument is True, the intersecting Sprites will be removed from their respective Group. </p>
<!--COMMENTS:pygame.sprite.groupcollide--> &nbsp;<br> 
<br></ul>


<a name="pygame.sprite.spritecollideany">
<big><b>pygame.sprite.spritecollideany</big></b><br><ul>
  <i>simple test if a Sprite intersects anything in a Group</i><br>
  <tt>pygame.sprite.spritecollideany(sprite, group): return bool</tt><br>
<p>Test if the given Sprite intersects with any Sprites in a Group. Intersection is determined by comparing of the <tt>Sprite.rect</tt> attribute of each Sprite. </p>
<p>This collision test can be faster than <tt><a href="sprite.html#pygame.sprite.spritecollide">pygame.sprite.spritecollide</a> - <font size=-1>find Sprites in a Group that intersect another Sprite</font></tt> since it has less work to do. </p>
<!--COMMENTS:pygame.sprite.spritecollideany--> &nbsp;<br> 
<br></ul>
<br></ul>

</body></html>
