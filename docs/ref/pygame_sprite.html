<html>
<title>pygame.sprite</title>
<body bgcolor=#aaeebb text=#000000 link=#331111 vlink=#331111>


<table cellspacing=3 width=100%><tr><td bgcolor=#00000>
<table width=100%><tr><td bgcolor=c2fc20 align=center>
    <a href=http://www.pygame.org>
    <img src=../pygame_tiny.gif border=0 width=200 height=60></a><br>
    <b>pygame&nbsp;&nbsp;&nbsp;documentation</b>
</td><td bgcolor=6aee28 align=center valign=top width=100%>

	||&nbsp;
	<a href=http://www.pygame.org>Home</a> &nbsp;||&nbsp;
	<a href=../index.html>Help Contents</a> &nbsp;||
	<br>&nbsp;<br>

|| <a href=pygame.html>pygame</a> || 
<a href=pygame_cdrom.html>cdrom</a> || 
<a href=pygame_constants.html>constants</a> || 
<a href=pygame_display.html>display</a> || 
<a href=pygame_draw.html>draw</a> || 
<a href=pygame_event.html>event</a> ||<br>
|| <a href=pygame_font.html>font</a> || 
<a href=pygame_image.html>image</a> || 
<a href=pygame_joystick.html>joystick</a> || 
<a href=pygame_key.html>key</a> || 
<a href=pygame_mixer.html>mixer</a> || 
<a href=pygame_mixer_music.html>mixer_music</a> ||<br>
|| <a href=pygame_mouse.html>mouse</a> || 
<a href=pygame_movie.html>movie</a> || 
<a href=pygame_sndarray.html>sndarray</a> || 
<a href=pygame_surfarray.html>surfarray</a> || 
<a href=pygame_time.html>time</a> || 
<a href=pygame_transform.html>transform</a> ||<br>
&nbsp;<br>|| <a href=CD.html>CD</a> || 
<a href=Channel.html>Channel</a> || 
<a href=Clock.html>Clock</a> || 
<a href=Font.html>Font</a> || 
<a href=Joystick.html>Joystick</a> || 
<a href=Movie.html>Movie</a> ||<br>
|| <a href=Rect.html>Rect</a> || 
<a href=Sound.html>Sound</a> || 
<a href=Surface.html>Surface</a> ||<br>
&nbsp;<br>|| <a href=pygame_cursors.html>cursors</a> || 
<a href=pygame_sprite.html>sprite</a> ||<br>


</td></tr></table></td></tr></table>
<br>
<h2 align=center>pygame.sprite</h2>
<br>&nbsp;<br>
This module contains a base class for sprite objects. Also
several different group classes you can use to store and
identify the sprites. Some of the groups can be used to
draw the sprites they contain. Lastly there are a handful
of collision detection functions to help you quickly find
intersecting sprites in a group.
<br>&nbsp;<br>
The way the groups are designed, it is very efficient at
adding and removing sprites from groups. This makes the
groups a perfect use for cataloging or tagging different
sprites. instead of keeping an identifier or type as a
member of a sprite class, just store the sprite in a
different set of groups. this ends up being a much better
way to loop through, find, and effect different sprites.
It is also a very quick to test if a sprite is contained
in a given group.
<br>&nbsp;<br>
You can manage the relationship between groups and sprites
from both the groups and the actual sprite classes. Both
have add() and remove() functions that let you add sprites
to groups and groups to sprites. Both have initializing
functions that can accept a list of containers or sprites.
<br>&nbsp;<br>
The methods to add and remove sprites from groups are
smart enough to not delete sprites that aren't already part
of a group, and not add sprites to a group if it already
exists. You may also pass a sequence of sprites or groups
to these functions and each one will be used.
<br>&nbsp;<br>
The design of the sprites and groups is very flexible.
There's no need to inherit from the provided classes, you
can use any object you want for the sprites, as long as it
contains "add_internal" and "remove_internal" methods,
which are called by the groups when they remove and add
sprites. The same is true for containers. A container
can be any python object that has "add_internal" and
"remove_internal" methods that the sprites call when
they want add and remove themselves from containers. The
containers must also have a member named "_spritegroup",
which can be set to any dummy value.
<br>&nbsp;<br>

<hr>

<table>
<tr><td><a href=#groupcollide>groupcollide</a></td><td> -
       collision detection between group and group</td></tr>


<tr><td><a href=#spritecollide>spritecollide</a></td><td> -
       collision detection between sprite and group</td></tr>


<tr><td><a href=#spritecollideany>spritecollideany</a></td><td> -
       finds any sprites that collide</td></tr>


</table>

<hr>

<a name=groupcollide><font size=+2><b>groupcollide
</b></font><br><font size=+1><tt>
pygame.sprite.groupcollide(groupa, groupb, dokilla, dokillb) -> dict
</tt></font><ul>
       given two groups, this will find the intersections
       between all sprites in each group. it returns a
       dictionary of all sprites in the first group that
       collide. the value for each item in the dictionary
       is a list of the sprites in the second group it
       collides with. the two dokill arguments control if
       the sprites from either group will be automatically
       removed from all groups.
</ul><br>&nbsp;<br>

<a name=spritecollide><font size=+2><b>spritecollide
</b></font><br><font size=+1><tt>
pygame.sprite.spritecollide(sprite, group, dokill) -> list
</tt></font><ul>
       given a sprite and a group of sprites, this will
       return a list of all the sprites that intersect
       the given sprite.
       all sprites must have a "rect" value, which is a
       rectangle of the sprite area. if the dokill argument
       is true, the sprites that do collide will be
       automatically removed from all groups.
</ul><br>&nbsp;<br>

<a name=spritecollideany><font size=+2><b>spritecollideany
</b></font><br><font size=+1><tt>
pygame.sprite.spritecollideany(sprite, group) -> sprite
</tt></font><ul>
       given a sprite and a group of sprites, this will
       return return any single sprite that collides with
       with the given sprite. If there are no collisions
       this returns None.
       
       if you don't need all the features of the
       spritecollide function, this function will be a
       bit quicker.
       
       all sprites must have a "rect" value, which is a
       rectangle of the sprite area.
</ul><br>&nbsp;<br>


<hr>
</body></html>
