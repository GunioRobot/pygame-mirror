I don't think a transformation matrix is quite what you are looking
for for these kinds of controls.  That is all done in software, post
processing the image.  What I mean is controls that directly tell the
hardware what it should be doing.  I'm not sure QT supports it though.

I think the line you want to edit to fix the color stuff is

surf = SDL_CreateRGBSurface (0, self->boundsRect.right,
self->boundsRect.bottom, 32, 0xFF<<16, //bij linux is het 24
                                    0xFF<<8, 0xFF, 0);

That is a 32 bit surface currently set up to be _RGB, and is the alpha
channel.  The raw data you are pulling in might be something like
BGRA, which could explain the red and green being swapped.  Does
everything have a blue tint to it too?  You might try experimenting
with stuff like:

surf = SDL_CreateRGBSurface (0, self->boundsRect.right,
self->boundsRect.bottom, 32, 0xFF<<24, 0xFF<<16, 0xFF<<8, 0xFF);

Keep in mind though, as I have stated before, you really want to allow
for the flexibility of different surface depths, not just 32 bit.
This is more important than stuff like the transformation matrix.

/* Values for PixMap.pixelFormat (BE = Big Endian, LE = Little Endian)*/
enum {
                                        /* The original pixel formats supported by 32-bit Color Quickdraw*/
  k1MonochromePixelFormat       = 0x00000001, /* 1 bit indexed*/
  k2IndexedPixelFormat          = 0x00000002, /* 2 bit indexed*/
  k4IndexedPixelFormat          = 0x00000004, /* 4 bit indexed*/
  k8IndexedPixelFormat          = 0x00000008, /* 8 bit indexed*/
  k16BE555PixelFormat           = 0x00000010, /* 16 bit BE rgb 555 (Mac)*/
  k24RGBPixelFormat             = 0x00000018, /* 24 bit rgb */
  k32ARGBPixelFormat            = 0x00000020, /* 32 bit argb    (Mac)*/
                                        /* QuickTime additions*/
  k1IndexedGrayPixelFormat      = 0x00000021, /* 1 bit indexed gray*/
  k2IndexedGrayPixelFormat      = 0x00000022, /* 2 bit indexed gray*/
  k4IndexedGrayPixelFormat      = 0x00000024, /* 4 bit indexed gray*/
  k8IndexedGrayPixelFormat      = 0x00000028, /* 8 bit indexed gray*/
  k16LE555PixelFormat           = 'L555', /* 16 bit LE rgb 555 (PC)*/
  k16LE5551PixelFormat          = '5551', /* 16 bit LE rgb 5551*/
  k16BE565PixelFormat           = 'B565', /* 16 bit BE rgb 565*/
  k16LE565PixelFormat           = 'L565', /* 16 bit LE rgb 565*/
  k24BGRPixelFormat             = '24BG', /* 24 bit bgr */
  k32BGRAPixelFormat            = 'BGRA', /* 32 bit bgra    (Matrox)*/
  k32ABGRPixelFormat            = 'ABGR', /* 32 bit abgr    */
  k32RGBAPixelFormat            = 'RGBA', /* 32 bit rgba    */
  kYUVSPixelFormat              = 'yuvs', /* YUV 4:2:2 byte ordering 16-unsigned = 'YUY2'*/
  kYUVUPixelFormat              = 'yuvu', /* YUV 4:2:2 byte ordering 16-signed*/
  kYVU9PixelFormat              = 'YVU9', /* YVU9 Planar    9*/
  kYUV411PixelFormat            = 'Y411', /* YUV 4:1:1 Interleaved  16*/
  kYVYU422PixelFormat           = 'YVYU', /* YVYU 4:2:2 byte ordering   16*/
  kUYVY422PixelFormat           = 'UYVY', /* UYVY 4:2:2 byte ordering   16*/
  kYUV211PixelFormat            = 'Y211', /* YUV 2:1:1 Packed   8*/
  k2vuyPixelFormat              = '2vuy' /* UYVY 4:2:2 byte ordering   16*/
};

/*
MatrixRecord matrix;
short i, j;
Fixed minusOne = Long2Fix(-1L);
Fixed PlusOne = Long2Fix(1L);
Fixed zero = Long2Fix(0L);

ImageDescriptionHandle imageDesc = (ImageDescriptionHandle)NewHandle(0);

// retrieve a channelÃ•s current sample description, the channel returns a sample description that is
// appropriate to the type of data being captured
//theErr = SGGetChannelSampleDescription(self->channel, (Handle)imageDesc);
if (theErr != noErr) {
    PyErr_Format(PyExc_SystemError,
    "SG sample description");
    return 0;
}

Rect dstRect;
dstRect.top = 0;
dstRect.left = 0;
dstRect.bottom = 200;
dstRect.right = 200;

RectMatrix(&matrix, &self->boundsRect, &dstRect);
theErr = SGSetChannelMatrix(self->channel, &matrix);
if (theErr != noErr) {
    PyErr_Format(PyExc_SystemError,
    "set matrix fail");
    return 0;
}
*/




/*
if (true) {
    printf("View = flip\n");
    // err = SGGetChannelMatrix(videoChannel, &mat);
    // keyPrint("return from get matrix = %d\n", err);
    if (!(matrix = malloc(sizeof(MatrixRecord)))) {
        printf(" malloc failed for MatrixRecord.\n");
        return;
    }
    matrix->matrix[0][0] = zero;
    matrix->matrix[0][1] = zero;
    matrix->matrix[0][2] = zero;

    matrix->matrix[1][0] = zero;
    matrix->matrix[1][1] = zero;
    matrix->matrix[1][2] = zero;

    matrix->matrix[2][0] = (Fract) 0x00000000L;
    matrix->matrix[2][1] = (Fract) 0x00000000L;
    matrix->matrix[2][2] = (Fract) 0x00000000L;
    
    theErr = SGGetChannelMatrix(self->channel, matrix);
    
    for (i=0; i<3; ++i)
        for (j=0; j<3; ++j)
            printf("matrix->matrix[%d][%d] = %d\n", i, j, matrix->matrix[i][j]);
    printf("return from get matrix = %d\n", theErr);
    
    ScaleMatrix(matrix, fixed1, minusOne, 0, 0);
    TranslateMatrix(matrix, Long2Fix(self->boundsRect.right), 0);
    
    
    theErr = SGSetChannelMatrix(self->channel, matrix);
    printf("return from set matrix = %d\n", theErr);
    
    
    matrix->matrix[0][0] = PlusOne;
    matrix->matrix[0][1] = zero;
    matrix->matrix[0][2] = zero;

    matrix->matrix[1][0] = zero;
    matrix->matrix[1][1] = PlusOne;
    matrix->matrix[1][2] = zero;

    matrix->matrix[2][0] = (Fract) 0x00000000L;
    matrix->matrix[2][1] = (Fract) 0x00000000L;
    matrix->matrix[2][2] = fract1;
    

    for (i=0; i<3; ++i)
        for (j=0; j<3; ++j)
            printf("matrix->matrix[%d][%d] = %d\n", i, j, matrix->matrix[i][j]);
    
    theErr = SGSetChannelMatrix(self->channel, matrix);
    printf("return from set matrix = %d\n", theErr);
    SGVideoDigitizerChanged(self->channel);
} else {
    printf("View = normal\n");
}
*/

/* I don't use thse
case V4L2_PIX_FMT_SBGGR8:
    if (buffer_size >= self->size) {
        switch (self->color_out) {
            case RGB_OUT:
                sbggr8_to_rgb(image, surf->pixels, self->width, self->height, surf->format);
                break;
            case HSV_OUT:
                sbggr8_to_rgb(image, surf->pixels, self->width, self->height, surf->format);
                rgb_to_hsv(surf->pixels, surf->pixels, self->size, V4L2_PIX_FMT_SBGGR8, surf->format);
                break;
            case YUV_OUT:
                sbggr8_to_rgb(image, surf->pixels, self->width, self->height, surf->format);
                rgb_to_yuv(surf->pixels, surf->pixels, self->size, V4L2_PIX_FMT_SBGGR8, surf->format);
                break;
        }
    } else {
        SDL_UnlockSurface (surf);
        return 0;
    }
    break;

case V4L2_PIX_FMT_YUV420:
    if (buffer_size >= (self->size * 3) / 2) {
        switch (self->color_out) {
            case YUV_OUT:
                yuv420_to_yuv(image, surf->pixels, self->width, self->height, surf->format);
                break;
            case RGB_OUT:
                yuv420_to_rgb(image, surf->pixels, self->width, self->height, surf->format);
                break;
            case HSV_OUT:
                yuv420_to_rgb(image, surf->pixels, self->width, self->height, surf->format);
                rgb_to_hsv(surf->pixels, surf->pixels, self->size, V4L2_PIX_FMT_YUV420, surf->format);
                break;
        }
    } else {
        SDL_UnlockSurface (surf);
        return 0;
    }
    break;
*/

/*
//this isn't really necessary
case k16BE555PixelFormat:
    if (buffer_size >= self->size * 2) {
        printf("RGB44...\n");
        switch (self->color_out) {
            case RGB_OUT:
                rgb444_to_rgb(image, surf->pixels, self->size, surf->format);
                break;
            case HSV_OUT:
                rgb_to_hsv(image, surf->pixels, self->size, V4L2_PIX_FMT_RGB444, surf->format);
                break;
            case YUV_OUT:
                rgb_to_yuv(image, surf->pixels, self->size, V4L2_PIX_FMT_RGB444, surf->format);
                break;
        }
    } else {
        SDL_UnlockSurface (surf);
        return 0;
    }
    break;
*/